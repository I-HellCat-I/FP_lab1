# Отчёт по лабораторной работе №1 по функциональному программированию


#### **Выполнил:** Лобов Максим Павлович
#### **Группа:** P3312
#### **ЯП:** Haskell

---

## 1. Описание проблемы

В рамках лабораторной работы требовалось решить две задачи с платформы Project Euler, используя различные подходы функционального программирования на языке Haskell, и на традиционном языке, в моём случае - Python.

### [Задача 10: Summation of primes](https://projecteuler.net/problem=10)
**Условие:** Сумма простых чисел меньше 10 равна $2 + 3 + 5 + 7 = 17$. Найдите сумму всех простых чисел меньше 2 000 000.
**Сложность:** $N = 2 \cdot 10^6$, значит можно перебирать числа до $\sqrt{n}$ -> тогда итоговая сложность будет: $O(n\sqrt{n})$

### [Задача 20: Factorial digit sum](https://projecteuler.net/problem=20)
**Условие:** $n!$ означает $n \times (n-1) \times \dots \times 3 \times 2 \times 1$. Найдите сумму цифр в числе $100!$.
**Сложность:** Результат $100!$ — (158 цифр). Для Haskell - используем Integer, а в Python int и так бесконечный

---

## 2. Ключевые элементы реализации

### 2.1. Предикаты и вспомогательные функции

Проверка простоты методом перебора делителей и разбиение числа на цифры.

```haskell
isPrime n = n > 1 && all (\x -> n `mod` x /= 0) [2 .. floor (sqrt (fromIntegral n))]

sumDigits n = sum (map digitToInt (show n))
```

### 2.2. Задача 10: Сумма простых чисел

**Модульная композиция (Filter + Fold):**
Классический Pipeline: генерация списка $\rightarrow$ фильтрация предикатом $\rightarrow$ свертка суммой.
```haskell
sumPrimesModular limit = foldl' (+) 0 (filter isPrime [2 .. (limit - 1)])
```

**Хвостовая рекурсия:**
Использование аккумулятора `acc` для накопления результата без сохранения состояния в стеке.
```haskell
go current acc
    | current >= limit = acc
    | isPrime current  = go (current + 1) (acc + current)
    | otherwise        = go (current + 1) acc
```

**Работа с бесконечными списками (Lazy Evaluation):**
Отделение логики генерации (`filter`) от условия остановки (`takeWhile`).
```haskell
primesInfinite = filter isPrime [2..]
sumPrimesLazy limit = sum (takeWhile (< limit) primesInfinite)
```

### 2.3. Задача 20: Сумма цифр факториала

**Свертка (Fold):**
Факториал вычисляется как свертка списка чисел умножением. Тип `Integer` в Haskell автоматически поддерживает длинную арифметику.
```haskell
solve20Modular n = sumDigits (foldl' (*) 1 [1 .. n])
```

**Бесконечные списки (Scan):**
Функция `scanl1` создает список всех промежуточных состояний аккумулятора (все факториалы сразу).
```haskell
factorialsInfinite = scanl1 (*) [1..]
-- Взятие (n-1)-го элемента из потока
result = sumDigits (factorialsInfinite !! (fromIntegral n - 1))
```

---

## 3. Выводы

1.  **Рекурсия vs Хвостовая рекурсия:**
    Обычная рекурсия в Haskell проста в написании, но непригодна для  больших итераций из-за переполнения стека. Хвостовая рекурсия (с аккумулятором) решает эту проблему и по производительности близка к циклам в C/C++ в хороших случаях
    
2.  **Модульность (Map/Filter/Fold):**
    Это наиболее мощный инструмент Haskell. Код читается как описание задачи: "свернуть отфильтрованный список".

3.  **Ленивые вычисления:**
    Бесконечные списки позволяют отделить логику *генерации* данных (например, "все простые числа") от логики *остановки* (например, "меньше N"). Это повышает переиспользуемость кода. В Python для этого требуются итераторы/генераторы (`yield`).

4.  **Сравнение с Python:**
    Python позволяет разработать решение задачи быстрее за счет его синтаксической простоты и гибкости типов. Однако Haskell заставляет думать о типах данных и чистоте функций, что приводит к более надежному и предсказуемому коду.
